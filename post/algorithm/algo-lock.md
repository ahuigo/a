---
title: 死锁
date: 2020-04-29
private: true
---
# 死锁
## 死锁发生
1. 线程A获得了锁1,线程B获得了锁2,
2. 这时线程A调用lock试图获得锁2,结果是需要挂起等待线程B释放锁2,
3. 而这时线程B也调用lock试图获得锁1,结果是需要挂起等待线程A释放锁1
4. 于是线程A和B都在等待对方释放自己才释放，从而造成两个都永远处于挂起状态，造成死锁。

## 避免死锁
几个方法
1. 保证加锁的顺序：所有线程在需要同时获得2个或3个锁时都应该按锁1、锁2、锁3的顺序获得
2. 避免死锁的银行家算法

### 银行家算法
1. 每一个线程进入系统时，它必须声明: 运行所需的`每种资源类型最大数目`，其数目不应超过系统所拥有每种资源总量
2. 当线程请求一组资源系统必须确定有足够资源分配给该进程，若有在进一步计算这些资源分配给进程后，是否会使系统处于不安全状态，不会（即若能在分配资源时找到一个安全序列），则将资源分配给它，否则等待。

## 检测死锁
2. 锁超时: lock 超时判断为死锁
3. 检测死锁：循环检测


---
title: go-test
date: 2018-09-27
---
# Preface
Go has a lightweight test framework composed of the go test command and the testing package.

1. test framework composed of the `go test` command and the `testing` package.
2. file with a name ending in `_test.go` that contains functions named `TestXXX` with signature `func (t *testing.T)`
3. if the function calls a failure function such as `t.Error or t.Fail`

## go test help
几个常用的参数：

    -bench regexp/wildcard 执行相应的 benchmarks，例如 -bench=.
    -run regexp/wildcard 只运行 regexp 匹配的函数，例如 -run=Array 那么就执行包含有 Array 开头的函数
    -cover 开启测试覆盖率
    -v 显示测试的详细命令

## unit test
Add a test to the stringutil package by creating the file ``$GOPATH/src/github.com/user/stringutil/reverse_test.go` containing the following Go code.

		package stringutil

		import "testing"

		func TestReverse(t *testing.T) {
			cases := []struct {
				in, want string
			}{
				{"Hello, world", "dlrow ,olleH"},
				{"Hello, 世界", "界世 ,olleH"},
				{"", ""},
			}
			for _, c := range cases {
				got := Reverse(c.in)
				if got != c.want {
					t.Errorf("Reverse(%q) == %q, want %q", c.in, got, c.want)
				}
			}
		}

Then run the test with go test:

		$ go test github.com/user/stringutil
		ok  	github.com/user/stringutil 0.165s

        $ go test github.com/path/to -run '^(TestReverse)$'

As always, if you are running the go tool from the package directory, you can omit the package path:

  	$ go test
  	ok  	github.com/user/stringutil 0.165s

### test log

    func TestHelloWorld(t *testing.T) {
        t.Log("hello world")
    }

testing.T 提供了几种日志输出方法:

    Log	打印日志，同时结束测试
    Logf	格式化打印日志，同时结束测试
    Error	打印错误日志，同时结束测试
    Errorf	格式化打印错误日志，同时结束测试
    Fatal	打印致命日志，同时结束测试
    Fatalf	格式化打印致命日志，同时结束测试

### 标记测试结果 
    fmt.Println("before fail")
    t.Fail()
    fmt.Println("after fail")

或者：

    if _, e := Division(6, 0); e == nil { //try a unit test on function
        t.Error("Division did not work as expected.") // 如果不是如预期的那么就报错
    } else {
        t.Log("one test passed.", e) //记录一些你期望记录的信息
    }

如果需要错误时终止

    t.FailNow()

### test debug
如果不在项目根目录会报错

    $ GO111MODULE=on git test -timeout 30s github.com/ahuigo/proj/service -run '^(TestGetXXX)$'
    can't load package: package github.com/ahuigo/proj/service: unknown import path "github.com/ahuigo/proj/service": cannot find module providing package github.com/ahuigo/proj/service

1. 要进入项目根目录
2. go.mod 的moudle 名字作为测试输出文件`module.test`

必须进入到项目根目录

    $ cd github.com/ahuigo/proj
    $ GO111MODULE=on git test -timeout 30s github.com/ahuigo/proj/service -run '^(TestGetXXX)$'

# bench test
## bench test rule
1.go test不会默认执行压力测试的函数，如果要执行压力测试需要带上参数`-test.bench`，语法:

    go test -test.bench="test_name_regex"
    go test -test.bench=".*"    表示测试全部的压力测试函数

2.其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母

    func BenchmarkXXX(b *testing.B) { ... }

3.在压力测试用例中,请记得在循环体内使用`testing.B.N`,以使测试可以正常的运行

    func Benchmark_Division(b *testing.B) {
        for i := 0; i < b.N; i++ { //use b.N for looping 
            Division(4, 5)
        }
    }
    func Benchmark_TimeConsumingFunction(b *testing.B) {
        b.StopTimer() //调用该函数停止压力测试的时间计数
        //....做一些初始化的工作,例如读取文件数据,数据库连接之类的,
        b.StartTimer() //重新开始时间
        for i := 0; i < b.N; i++ {
            Division(4, 5)
        }
    }

测试bench。。。

    $ go test -v -bench=. benchmark_test.go
    goos: linux
    goarch: amd64
    Benchmark_Division-4           20000000         0.33 ns/op
    PASS
    ok          command-line-arguments        0.700s

代码说明如下：
1. 第 1 行的-bench=.表示运行 benchmark_test.go 文件里的所有基准测试，和单元测试中的-run类似。
1. 第 4 行中显示基准测试名称，2000000000 表示测试的次数，也就是 testing.B 结构中提供给程序使用的 N。“0.33 ns/op”表示每一个操作耗费多少时间（纳秒）。


### 自定义测试时间
通过-benchtime参数可以自定义测试时间，例如：

    $ go test -v -bench=. -benchtime=5s benchmark_test.go

### count执行多少次
如果想多次执行

    go test -test.bench=".*" -count=5


### 测试cpu
示例

    $ cat popcnt/popcunt_test.go
    package popcnt

    import (
        "testing"
    )

    const m1 = 0x5555555555555555
    const m2 = 0x3333333333333333
    const m4 = 0x0f0f0f0f0f0f0f0f
    const h01 = 0x0101010101010101

    func popcnt(x uint64) uint64 {
        x -= (x >> 1) & m1
        x = (x & m2) + ((x >> 2) & m2)
        x = (x + (x >> 4)) & m4
        return (x * h01) >> 56
    }

    func BenchmarkPopcnt(b *testing.B) {
        for i := 0; i < b.N; i++ {
            x := i
            x -= (x >> 1) & m1
            x = (x & m2) + ((x >> 2) & m2)
            x = (x + (x >> 4)) & m4
            _ = (x * h01) >> 56
        }
    }

exec:

    # go test -run=文件名字 -bench=bench名字 -cpuprofile=生产的cprofile文件名称 文件夹
    $ go test -bench=".*" -cpuprofile=cpu.profile ./popcnt/
    BenchmarkPopcnt-4   	2000000000	         0.36 ns/op

    $ ls
    cpu.profile popcnt popcnt.test

#### 进入交互
进入command 交互模式

    $ go tool pprof popcnt.test cpu.profile
    Entering interactive mode (type "help" for commands)
    (pprof) top

web 交互:

    $ go tool pprof --web popcnt.test cpu.profile 进入web模式

text模式

    $ go tool pprof --text mybin http://myserver:6060:/debug/pprof/profile

更多: 运行 go tool pprof 来得到最完整的列表


### 测试内存
基准测试可以对一段代码可能存在的内存分配进行统计，下面是一段使用字符串格式化的函数，内部会进行一些分配操作。

    func Benchmark_Alloc(b *testing.B) {
        for i := 0; i < b.N; i++ {
            fmt.Sprintf("%d", i)
        }
    }

在命令行中添加-benchmem参数以显示内存分配情况，参见下面的指令：

    $ go test -v -bench=Alloc -benchmem benchmark_test.go
    goos: linux
    goarch: amd64
    Benchmark_Alloc-4 20000000 109 ns/op 16 B/op 2 allocs/op
    PASS
    ok          command-line-arguments        2.311s

代码说明如下：
1. 第 1 行的代码中-bench后添加了 Alloc，指定只测试 Benchmark_Alloc() 函数。
1. 第 4 行代码的“16 B/op”表示每一次调用需要分配 16 个字节，“2 allocs/op”表示每一次调用有两次分配。


## todo
以上参考：
http://c.biancheng.net/view/124.html
https://studygolang.com/articles/7051
